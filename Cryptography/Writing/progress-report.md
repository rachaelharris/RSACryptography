We have made tremendous progress on our project, and are currently sitting in a very good place.  There's a lot of things that we had to learn, and it wasn't easy, but I'm certainly proud of where we are right now.  In the beginning, we outlined the things we were going to try and accomplish, and the different features we wanted to implement, but as of now not all of those things are done.  In the coming days, the code will be edited in an effort to make those changes happen, but there are still some issues that need to be worked out before we dive into making the program more complex and detailed.

In this section, we go over what we have accomplished so far, and put the problems we are currently having aside.  First and foremost, the actual algorithms needed to make RSA work are fully implemented and tested.  We wrote pseudocode for all of them, turned them into Latex files, and uploaded the PDFs to the repository.  After, they were turned into Java code, with a little fine tuning for the actual implementation, as it is not a straight shot from pseudocode to high-level programming.  Fortunately, they all seem to be in working order, as they have been tested thoroughly.

In the `Mathematics` class, there are 3 methods that are crucial for RSA cryptography.  I learned the theory behind them from an actual math course here at Allegheny, namely the cryptosystems course, but I wrote pseudocode and implemented them on my own just from the examples that we did in class.  

The most challenging one is definitely the Successive Squaring method, as it had to be manipulated the most to be implemented into Java code.  The idea behind needing an algorithm like that is simple: when working in a different algebraic system, such as being in a modulus, operations that seem way too big to do are made possible by keeping the numbers within the scope of the problem.  By constructing it carefully, we can raise large numbers to large powers in a given modulus and successfully get an answer for a problem.  So, what would normally take up a lot of computing power to get a really big number and then perform modulus division on it, we break up the multiplication into steps that are manageable, and don't always need to be done by a computer.

The second most challenging algorithm was the Euclidean Algorithm, the ideas of which are not directly used in the actual program, but whose fundamental idea gives a strong basis for an understanding for the one that needs to be used, the Extended Euclidean Algorithm.  Simply put, the Euclidean Algorithm, found in the `Mathematics` class, is an efficient way for finding the greatest common divisor for two numbers.  Again, the steps of which I learned in a class outside of this one, but still had to make it work in actual code.  I found it easier to start working in Java rather than beginning with writing pseudocode for this algorithm, so it was the high-level programming that was turned into Latex later.

Finally, the `powerOf` method was implemented.  It's extremely simple, take a base and a power and compute the multiplication, returning the result.  It was certainly the easiest to implement and write pseudocode for, but ironically, it has the most limitation.  The problem comes from the fact that we are using Java to write the program, and there is a limit to how big an integer can be.  This means that you always have to be careful not to go past the scope of what Java can do, and not give it numbers too big.  More importantly, since the `powerOf` method is often used in `successiveSquaring`, it gave us limitations there as well.  This forced us to pick from a pool of primes that are much smaller and more restricted than initially intended, but it doesn't take away from the core purpose of the program.

In the next session, we discuss the issues that we are currently facing and the ones that we predict we will run into when trying to implement more features and detail to the program.  As I mentioned before, we have had much success while learning about and implementing RSA, but there are some limitations that we are dealing with, and some problems that need to be addressed.  We will also talk about our plan for resolving the said issues.

First and foremost, the classes aren't communicating properly, and we aren't quite sure why.  They are all in the same folder and have the same package declaration, so I'm not quite sure what the problem is.  We have tried multiple solutions, but we can't seem to get the classes to recognize each other, as every time I try to use the `Mathematics` class from `Main`, it throws me an error and says that it can't find `Mathematics`.  One solution to the problem, of course, would be to put all the methods from the `Mathematics` class into `Main`, but that defeats the whole purpose of why we wanted to have separate classes in the first place, it makes things much easier to understand.  All of our computation can be done in the separate Java file, making the `Main` class, which has the actual process of Alice and Bob communicating, much easier to understand.

The next thing on the list is hardly an issue, but rather something that we hope to implement in the future.  The goal is to encrypt the public numbers, so whenever Alice or Bob publishes a number on the insecure channel, it doesn't just show the number, but rather a random sequence of characters that only the other knows how to decrypt.  Basically, our hope is to add a second layer of encryption, for a more realistic effect in the terminal window.  Obviously, this doesn't give the program any actual credibility as a real cryptosystem, and it's true, there is literally no reason for Alice and Bob to be encrypting their messages, but the idea is that we are pretending they are trying to communicate over an insecure channel and simulate what it would be like.

Finally, it would be very cool to have a better implementation for the Extended Euclidean algorithm.  The way it stands now, it technically works, but is super inefficient and time-consuming.  The reason is, of course, we just wanted to get something that technically works so our program functions correctly as a whole.  However, spending time on coming up with a better solution would be a nice addition to polish the algorithms featured in our program.  At first glance, it seems like this will be pretty tricky, so it will be put at the end of the to-do list, as we are hoping to get a more advanced process for exchanging messages in the terminal window ready first.

Furthermore, we hope to be able to analyze our algorithms' runtimes, and make significant improvements to the Extended Euclidean Algorithm, as mentioned above.  That has by far the worst runtime out of all, and even though it still could at the end of the day, it shouldn't nearly be as bad as it is now.  Like I mentioned above, it works, but there is definitely room for improvement.
